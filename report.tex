\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage{graphicx}
\graphicspath{ {./Report Images/} }

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Marc Domingo  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}\label{introduction}
\subsection{Week 1}
\hspace{10mm} During the first week of Programming Languages, the class lectures went over the concept of \textit{Imperative vs Functional Programming} and \textit{Recursive Programming} in addition to a brief introduction to the programming language \textbf{Haskell}.
\subsection{Week 2}
\hspace{10mm} During the second week of Programming Languages, the class lectures went more into depth regarding techniques in how to use \textbf{Recursion} to solve problems, as well as introduced the concept of creating an \textit{Interpreter} in Haskell.
\subsection{Week 3} During the third week of Programming Languages, the class lectures went over the concept of Context and Parse Trees in relation to programming a calculator interpreter.
\subsection{Week 4} During the fourth week of Programming Languages, the lectures covered the concept of Lambda Calculus, specifically about its syntax and how to parse Lambda equations.
\subsection{Week 5} During the fifth week of Programming Languages, the lectures covered the concept of performing substitution in Lambda Calculus through pen-and-paper, and through an interpreter.
\subsection{Week 6} During the sixth week of Programming Languages, the languages covered the concept of how to substitute and rewrite variables within functions, before applying the concept to Lambda Calculus.
\subsection{Week 7} During the seventh week of Programming Languages, the lectures provided an introduction to the concept of Abstract Reduction Systems (ARS).
\subsection{Week 8} During the eighth, week of Programming Languages, the lectures covered the concepts of Confluence and Termination in how they relate to ARS.
\section{Homework}\label{homework}
\subsection{Week 1}

C++ Code for Greatest Common Denominator:
\begin{lstlisting}
#include <iostream>
using namespace std;

int gcd(int a, int b)
{
    if (a == 0)
    {
        return b;
    }
    
    if (b == 0)
    {
        return a;
    }
    
    if (a == b)
    {
        return a;
    }
    
    if (a > b)
    {
        return gcd((a - b), b);
    }
    
    if (b > a)
    {
        return gcd(a, (b - a));
    }
}

int main() {
    // Write C++ code here
    cout << "GCD of 9 and 33 is : " << gcd(9, 33);
    return 0;
}
\end{lstlisting}
    
    The function for calculating the Greatest Common Divisor (GCD) functions by first taking two integers as inputs, represented by \textbf{a} and \textbf{b}. In the case of inputs like gcd(9, 33), 9 and 33 are considered to be \textbf{a} and \textbf{b} in the gcd function respectively. The function first checks to see if either integer is \textit{0}, and in the case of either integer being zero, returns the other integer entered in the function as the gcd. If neither number is zero, the function checks to see if both integers are \textbf{equal to each other}. In the case that both integers are equal, the function returns the first integer as the gcd. If neither of the previous cases are met, the function then compares integer \textbf{a} and \textbf{b}. If integer \textbf{a} is larger, the function recursively calls itself, and \textit{integer a is replaced with (a - b)}. If integer \textbf{b} is larger, the function recursively calls itself, and \textit{integer b is replaced with (b - a).} The function \textit{continues making recursive calls} with modified numbers until a case where gcd is found.

\subsection{Week 2}
\begin{lstlisting}
len [] = 0
len (x:xs) = 1 + len xs

select_evens [] = []
select_evens [a] = []
select_evens (x:y:list) = y:(select_evens list)

select_odds [] = []
select_odds [a] = [a]
select_odds (x:y:list) = x:(select_odds list)

member _ [] = False
member n (x:xs)
  | x == n = True
  | otherwise = member n xs

append [] list_original = list_original
append (x:list_add) list_original = x:(append list_add list_original)

revert [] = []
revert (item:xs) = append (revert xs) [item]

less_equal [] [] = True
less_equal (x:list_one) (y:list_two) = if x <= y
									    then less_equal list_one list_two
									    else False
\end{lstlisting}
In the case of \textbf{select\textunderscore evens ["a","b","c","d","e"]}:
\begin{lstlisting}
select_evens ["a","b","c","d","e"] =
      "b":(select_evens ["c","d","e"]) =
      "b":"d":(select_evens ["e"]) =
      "b":"d":[] = 
      ["b","d"]
\end{lstlisting}
In the case of \textbf{select\textunderscore odds ["a","b","c","d","e"]}:
\begin{lstlisting}
select_odds ["a","b","c","d","e"] =
      "a":(select_odds ["c","d","e"]) =
      "a":"c":(select_odds ["e"]) =
      "a":"c":["e"] = 
      ["a","c","e"]
\end{lstlisting}
In the case of \textbf{member 2 [5,2,6]}:
\begin{lstlisting}
member 2 [5,2,6] = 
        member 2 [2,6] =          5 != 2
        True                      2 == 2
\end{lstlisting}
In the case of \textbf{member 3 [5,2,6]}:
\begin{lstlisting}
member 3 [5,2,6] = 
      member 3 [2,6] =          5 != 3
      member 3 [6] =            2 != 3      
      member 3 [] =             6 != 3
      False
\end{lstlisting}
In the case of \textbf{append [1,2] [3,4,5]}:
\begin{lstlisting}
append [1,2] [3,4,5] =
      1:(append [2] [3,4,5]) =
      1:(2:(append [] [3,4,5])) =
      1:(2:([3:4:5])) =
      [1,2,3,4,5]
\end{lstlisting}
In the case of \textbf{revert [1,2,3]}:
\begin{lstlisting}
revert [1,2,3] =
      append (revert [2,3]) [1] =
      append (append (revert [3]) [2]) [1] =
      append (append (append (revert []) [3]) [2]) [1] =
      append (append (append [] [3]) [2]) [1] =
      append (append ([3]) [2]) [1] =
      append (3:(append [] ([2]))) [1] =
      append (3:([2]) [1] =
      append [3,2] [1] =
      3:(append [2] [1]) =
      3:(2:(append [] [1])) =
      3:(2:([1])) =
      [3,2,1]
\end{lstlisting}
In the case of \textbf{less\textunderscore equal [1,2,3] [2,3,4]}:
\begin{lstlisting}
less_equal [1,2,3] [2,3,4] = 
      less_equal [2,3] [3,4] =          1 <= 2
      less_equal [3] [4] =              2 <= 3
      less_equal [] [] =                3 <= 4
      True
\end{lstlisting}
In the case of \textbf{less\textunderscore equal [1,2,3] [2,3,2]}:
\begin{lstlisting}
less_equal [1,2,3] [2,3,2] = 
      less_equal [2,3] [3,2] =          1 <= 2
      less_equal [3] [2] =              2 <= 3
      False                             3 > 2
\end{lstlisting}

\subsection{Week 3}
\begin{lstlisting}
hanoi 5 0 2
    hanoi 4 0 1
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
        move 0 1
        hanoi 3 2 1
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
            move 2 1
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
    move 0 2
    hanoi 4 1 2
        hanoi 3 1 0
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
            move 1 0
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
\end{lstlisting}
Movement solution for Towers of Hanoi with n Disks = 5:
\begin{lstlisting}
0->2
0->1
2->1
0->2
1->0
1->2
0->2
0->1
2->1
2->0
1->0
2->1
0->2
0->1
2->1
0->2
1->0
1->2
0->2
1->0
2->1
2->0
1->0
1->2
0->2
0->1
2->1
0->2
1->0
1->2
0->2
\end{lstlisting}
Within the computation for the Towers of Hanoi with \textit{n Disks = 5}, the word "Hanoi" appears a total of \textbf{31 times}. This can be expressed with the following equation:
$ Hanoi = 2^N - 1$, where \textit{N} is the number of disks from the initial tower.

\subsection{Week 4}
The Abstract Syntax Tree of $2 + 1$ is:

\includegraphics[width=15cm, height=8cm]{Report Images/week4_1.jpg}
\begin{lstlisting}
Plus (Num 2) (Num 1)
\end{lstlisting}


The Abstract Syntax Tree of $1 + 2 * 3$ is:

\includegraphics[width=15cm, height=8cm]{Report Images/week4_2.jpg}
\begin{lstlisting}
Plus (Num 1) (Times (Num 2) (Num 3))
\end{lstlisting}

The Abstract Syntax Tree of $1 + (2 * 3)$ is:

\includegraphics[width=15cm, height=8cm]{Report Images/week4_3.jpg}
\begin{lstlisting}
Plus (Num 1) (Times (Num 2) (Num 3))
\end{lstlisting}

The Abstract Syntax Tree of $(1 + 2) * 3$ is:

\includegraphics[width=15cm, height=8cm]{Report Images/week4_4.jpg}
\begin{lstlisting}
Times (Plus (Num 1) (Num 2)) (Num 3)
\end{lstlisting}

The Abstract Syntax Tree of $1 + 2 * 3 + 4 * 5 + 6$ is:

\includegraphics[width=15cm, height=8cm]{Report Images/week4_5.jpg}
\begin{lstlisting}
Plus (Plus (Plus (Num 1) (Times (Num 2) (Num 3))) (Times (Num 4) (Num 5))) (Num 6)
\end{lstlisting}


The abstract syntax tree of $1+2+3$ would be identical to the one of $(1+2)+3$ as the compiler would calculate from left to right as there are no other higher-order operations aside from addition.

\subsection{Week 5}
\textbf{Part 1:}

The Linearized Tree for $x$ is:
\begin{lstlisting}
x
Prog (EVar (Id "x"))
\end{lstlisting}

Its Abstract Syntax Tree:

\includegraphics[width=15cm, height=8cm]{Report Images/week5_1.jpg}

The Linearized Tree for x x is:
\begin{lstlisting}
x x
Prog (EApp (EVar (Id "x")) (EVar (Id "x")))
\end{lstlisting}

Its Abstract Syntax Tree:

\includegraphics[width=15cm, height=8cm]{Report Images/week5_2.jpg}

The Linearized Tree for x y is:
\begin{lstlisting}
x y
Prog (EApp (EVar (Id "x")) (EVar (Id "y")))
\end{lstlisting}

Its Abstract Syntax Tree:

\includegraphics[width=15cm, height=8cm]{Report Images/week5_3.jpg}

The Linearized Tree for x y z is:
\begin{lstlisting}
x y z
Prog (EApp (EApp (EVar (Id "x")) (EVar (Id "y"))) (EVar (Id "z")))
\end{lstlisting}

Its Abstract Syntax Tree:

\includegraphics[width=15cm, height=8cm]{Report Images/week5_4.jpg}

The Linearized Tree for \textbackslash  x.x is:
\begin{lstlisting}
\ x . x
Prog (EAbs (Id "x") (EVar (Id "x")))
\end{lstlisting}

Its Abstract Syntax Tree:

\includegraphics[width=15cm, height=8cm]{Report Images/week5_5.jpg}

The Linearized Tree for \textbackslash x.x x is:
\begin{lstlisting}
\ x . x x
Prog (EAbs (Id "x") (EApp (EVar (Id "x")) (EVar (Id "x"))))
\end{lstlisting}

Its Abstract Syntax Tree:

\includegraphics[width=15cm, height=8cm]{Report Images/week5_6.jpg}

The Linearized Tree for (\textbackslash x . (\textbackslash y . x y)) (\textbackslash x.x) z is:
\begin{lstlisting}
\ x . \ y . x y (\ x . x)z
Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EApp (EVar (Id "x")) (EVar (Id "y"))))) (EAbs (Id "x") (EVar (Id "x")))) (EVar (Id "z")))
\end{lstlisting}

Its Abstract Syntax Tree:

\includegraphics[width=15cm, height=8cm]{Report Images/week5_7.jpg}

The Linearized Tree for (\textbackslash x . \textbackslash y . x y z) a b c is:
\begin{lstlisting}
\ x . \ y . x y z a b c
Prog (EApp (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EApp (EApp (EVar (Id "x")) (EVar (Id "y"))) (EVar (Id "z"))))) (EVar (Id "a"))) (EVar (Id "b"))) (EVar (Id "c")))
\end{lstlisting}

Its Abstract Syntax Tree:

\includegraphics[width=15cm, height=8cm]{Report Images/week5_8.jpg}

\textbf{Part 2:}

Evaluating of Equations:
\begin{lstlisting}
  (\x.x) a = a         
  \x.x a = \x.x a           
  (\x.\y.x) a b = (\y. a) b = a    
  (\x.\y.y) a b = (\y. y) b = b   
  (\x.\y.x) a b c = (\y. a) b c = (a) c = a c 
  (\x.\y.y) a b c = (\y. y) b c = (b) c = b c
  (\x.\y.x) a (b c) = (\y. a) (b c) = a
  (\x.\y.y) a (b c) = (\y. y) (b c) = b c 
  (\x.\y.x) (a b) c = (\y. a b) c = a b 
  (\x.\y.y) (a b) c = (\y. y) c = c
  (\x.\y.x) (a b c) = (\y. a b c)
  (\x.\y.y) (a b c) = (\y. y)
\end{lstlisting}

\includegraphics[width=15cm, height=8cm]{Report Images/week5_9.jpg}

\subsection{Week 6}
\begin{lstlisting}
(\exp . \two . \three . exp two three)
(\m.\n. m n)
(\f.\x. f (f x))
(\f.\x. f (f (f x)))

=
((\m.\n. m n) (\f2.\x2. f2 (f2 x2)) (\f3.\x3. f3 (f3 (f3 x3))))
=
((\n. (\f2.\x2. f2 (f2 x2)) n) (\f3.\x3. f3 (f3 (f3 x3))))
=
((\f2.\x2. f2 (f2 x2)) (\f3.\x3. f3 (f3 (f3 x3))))
=
(\x2. (\f3.\x3. f3 (f3 (f3 x3))) ((\f3.\x3. f3 (f3 (f3 x3))) x2))
= 
(\x2. (\f3.\x3. f3 (f3 (f3 x3))) (\x3. x2 (x2 (x2 x3))))
=
(\x2. (\x3. (\x3. x2 (x2 (x2 x3))) ((\x3. x2 (x2 (x2 x3))) ((\x3. x2 (x2 (x2 x3))) x3))))
=
(\x2. (\x3. (\x3. x2 (x2 (x2 x3))) ((\x3. x2 (x2 (x2 x3))) ((x2 (x2 (x2 x3)))))))
=
(\x2. (\x3. (\x3. x2 (x2 (x2 x3))) ((x2 (x2 (x2 (x2 (x2 (x2 x3)))))))))
=
(\x2. (\x3. (x2 (x2 (x2 (x2 (x2 (x2 (x2 (x2 (x2 x3)))))))))))
\end{lstlisting}
\subsection{Week 7}

For lines 5-8 as shown through:
\begin{lstlisting}
evalCBN (EApp e1 e2) = case (evalCBN e1) of
    (EAbs i e3) -> evalCBN (subst i e2 e3)
    e3 -> EApp e3 e2
evalCBN x = x 
\end{lstlisting}
In \textit{Line 5}, \textit{e1} and \textit{e2} are bound to the left of \textit{=}, and the scope is the end of \textit{Line 7}. For \textit{Line 6}, the variables \textit{i} and \textit{e3} are bound to the left of \textit{->}, and the scope is the end of the same line. Meanwhile, in \textit{Line 7}, the variable \textit{e3} is bound to the left of \textit{->}, and its scope is the end of the same line. Finally, for \textit{Line 8}, the variable \textit{x} is bound to the left of \textit{=}, and its scope is the end of the same line.
\\
\\
For lines 18-22 as shown through:
\begin{lstlisting}
subst id s (EAbs id1 e1) = 
    -- to avoid variable capture, we first substitute id1 with a fresh name inside the body of the Lambda-abstraction, obtaining e2. Only then do we proceed to apply substitution of the original s for id in the body e2.
    let f = fresh (EAbs id1 e1)
        e2 = subst id1 (EVar f) e1 in 
        EAbs f (subst id s e2)
\end{lstlisting}
In \textit{Line 18}, the variables \textit{id}, \textit{s}, \textit{id1}, and \textit{e1} are all bound to the left of \textit{=}, and the scope is the end of \textit{Line 22}. Meanwhile, in \textit{Line 20}, the variable \textit{f} is bound to the left of \textit{=}, and the scope is also the end of \textit{Line 22}. Lastly, on \textit{Line 21}, the variable \textit{e2} is bound by \textit{=}, and its scope is the end of \textit{Line 22} as well.
\\
\\
Item 3:
\begin{lstlisting}
--Idea:
(\x.\y.x) y z = (\fresh.y) z = y

(EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "x")))) (EVar (Id "y"))) (EVar (Id "z")))

-- In first EApp, (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "x")))) (EVar (Id "y"))) is e1, (EVar (Id "z")) is e2
-- In second EApp, (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "x")))) is e1, (EVar (Id "y")) is e2

= -- Line 5
evalCBN ( ( evalCBN (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "x")))) (EVar (Id "y"))) ) (EVar (Id "z")) )

    -- inner evalCBN
    -- Line 6
    evalCBN (subst ((EAbs (Id "x")) (EVar (Id "y")) (EAbs (Id "y") (EVar (Id "x")))))
    
        -- Line 18
        -- Line 20
        f = fresh ((EAbs (Id "y") (EVar (Id "x"))))
        -- consider \y now \y0
        -- Line 21
        e2 = subst (Id "y") (EVar "y0") (EVar (Id "x"))
        -- Line 16
        EAbs (Id "y0") (subst (Id "y") (EVar (Id "y")) (EVar (Id "x")))
        -- Line 16
        
    evalCBN (EAbs (Id "y0") (EVar (Id "y")))
    
= -- Line 7
evalCBN (EApp (EAbs (Id "y0")) (EVar (Id "y"))) (EVar (Id "z"))
= -- Line 6
evalCBN (subst (Id "y0") (EVar (Id "z")) (EVar (Id "y")))
= -- Line 16
evalCBN (EVar (Id "y"))
= -- Line 8
EVar (Id "y")
\end{lstlisting}
1. \textit{A = \{ \}}
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_1.jpg}
\\2. \textit{A = \{a\}} and \textit{R = \{\}}
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_2.jpg}
\\3. \textit{A = \{a\}} and \textit{R = \{(a,a)\}}
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_3.jpg}
\\4. \textit{A = \{a, b, c\}} and \textit{R = \{(a,b), (a,c)\}}
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_4.jpg}
\\5. \textit{A = \{a,b\}} and \textit{R = \{(a,a),(a,b)\}}
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_5.jpg}
\\6. \textit{A = \{a, b, c\}} and \textit{R = \{(a,b),(b,b),(a,c)\}}
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_6.jpg}
\\7. \textit{A = \{a, b, c\}} and \textit{R = \{(a,b),(b,b),(a,c),(c,c)\}}
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_7.jpg}
\\
\\Example for cases
\\ 1. Confluent: True, Terminating: True, Unique Normal Forms: True
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_8.jpg}
\\ 2. Confluent: True, Terminating: True, Unique Normal Forms: False
\\  No example of this would exist, as in order for an ARS to be Terminating and Confluent it would need an Unique Normal Form as if one of the normal forms of the initial term reduces to itself, while the other normal form reduces to that same normal form, the ARS would no longer be Terminating as it can infinitely reduce to itself.
\\ 3. Confluent: True, Terminating: False, Unique Normal Forms: True
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_9.jpg}
\\ 4. Confluent: True, Terminating: False, Unique Normal Forms: False
\\ a points to itself, add picture later
\\ 5. Confluent: False, Terminating: True, Unique Normal Forms: True
\\ There is no example of this as in order for there to be a possibility of having an Unique Normal Form, the ARS must be at the very least Confluent, making "Confluence: False" an impossibility to have alongside "Unique Normal Form: False." 
\\ 6. Confluent: False, Terminating: True, Unique Normal Forms: False
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_11.jpg}
\\ 7. Confluent: False, Terminating: False, Unique Normal Forms: True
\\ There is no example of this as in order for an ARS to have a Unique Normal Form, at its base, the ARS must be at least Confluent, making "Confluence: False" an impossibility to have alongside "Unique Normal Form: True."
\\ 8. Confluent: False, Terminating: False, Unique Normal Forms: False
\\ \includegraphics[width=15cm, height=8cm]{Report Images/week7_7.jpg}
\subsection{Week 8}
For the rewrite rules:
\begin{lstlisting}
  aa -> a
  bb -> b
  ba -> ab
  ab -> ba
\end{lstlisting}
\begin{enumerate}
    \item The ARS does not terminate because the output of the last rewrite rule is the input of the third rewrite rule, and the output of the third rule is the input of the last rule. This results in the potential for an infinitely rewriting function, and thus the ARS does not terminate.
    \item The normal forms of this ARS are \textit{a} and \textit{b}.
    \item The main change that would be made to the function would be to eliminate the fourth rule. Thus the ARS would have 3 normal forms: \textit{a}, \textit{b}, and \textit{ab}.
    \item The normal forms within the context of the ARS are a single form of a duplicate term. Because of this, it can be said that the primary function of the ARS is to reduce any duplicate terms until there are no longer any duplicates.
\end{enumerate}
\section{Project}\label{Project}
\subsection{Specification}
For my project in Programming Languages (Fall 2022), I intend on performing data analysis on a data set that is publicly available from GitHub. To accomplish this, the following would have to occur (in order):
\begin{enumerate}
    \item Receive approval from Dr. Kurtz for this specific project idea
    \item Come up with specific questions to answer about the Programming Languages data set, the responses to which can be modeled through various statistical models such as Linear/Logistic Regression Graphs, Data Cluster Graphs, Feature Reduction, LASSO Graphs, and/or Principle Component Analysis (PCA)
    \item Receive approval from Dr. Kurtz about the questions and the overall documentation of the data analysis report
    \item Download or import the data set from GitHub into Google Colab, this can be accomplished by replicating a specific iteration of the GitHub Programming Languages data set in an Excel sheet 
    \item Using the Pandas package for Python, create statistical models to respond to each of the questions created for the report
    \item By the last day of October, provide a PDF of the Google Colab Notebook containing the compiled statistical models as a proof of implementation for this project. This can also be accomplished by embedding the Python code into the "Prototype" subsection of \textit{report.tex}, with each code block being above the respective model that it generated when compiled 
    \item Write report for the analysis of the data set itself, explaining the process of selecting which model(s) to accept, reject, or if any model provided any surprising results about the data set in addition to providing a response to each of the questions created from \textbf{step 4}. A rough draft of this report should be submitted and present within the "Documentation" subsection of \textit{report.tex}
\end{enumerate}
\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}

\section{Conclusions}\label{Conclusions}
\dots
\end{document}